# 1. Подсчитать, сколько было выделено памяти под переменные в ранее разработанных
# программах в рамках первых трех уроков. Проанализировать результат и определить
# программы с наиболее эффективным использованием памяти.
# Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько вариантов кода для
# одной и той же задачи. Результаты анализа вставьте в виде комментариев к коду. Также укажите в
# комментариях версию Python и разрядность вашей ОС

# Windows 10 Pro 64-разрядная операционная система
# Python 3.9.5

# 3_4. Определить, какое число в массиве встречается чаще всего.

from time import time
from random import randint
from sys import getsizeof

a = [randint(0, 10) for i in range(10000)]
print(a)

# 1ый вариант через словарь
start1 = time()
b = dict.fromkeys(a, 0)
for i in a:
    b[i] += 1
max_n = max(b, key=b.get)
print(f"Число {max_n} встречается {b[max_n]} раз(а) ")
end1 = time()

# Временная сложность - линейная O(n)
# Пространственная сложность - O(n) линейная. Размер при n = 10000 - 668 б
# В данном случае все зависит сколько уникальных значений содержит массив. В моем случае их 10, поэтому и размер у
# словаря вышел небольшой по сравнению со вторым вариантом. Но в худшем случае все равно будет сложность O(n). Если
# сделать изначальный массив из randint(0, 10000) при том же n - размер уже будет - 295028 б


# 2ой вариант через новый список
start2 = time()
a_frq = []
for i in a:
    a_frq.append(a.count(i))
max_frq = max(a_frq)
print(f"Число {a[a_frq.index(max_frq)]} встречается {max_frq} раз(а)")
end2 = time()
# Временная сложность - O(n**2) Квадратичная, так как count(i) по сути вложенный цикл.
# Пространственная сложность - O(n) линейная, Размер при n = 10000 - 85176 б


# 3ий вариант через вложенный цикл
start3 = time()
max_n2 = a[0]
max_frq2 = 1
for i in range(len(a)):
    frq = 1
    for k in range(i + 1, len(a)):
        if a[i] == a[k]:
            frq += 1
    if frq > max_frq2:
        max_frq2 = frq
        max_n2 = a[i]
print(f"Число {max_n2} встречается {max_frq2} раз(а)")
end3 = time()

# Временная сложность - O(n**2) Квадратичная
# Пространственная сложность - O(n) Константная, Размер при n = 10000 - 56 б

print(end1 - start1, 'c - скорость работы 1ого варианта')
print(getsizeof(b)+getsizeof(max_n))
print(end2 - start2, 'c - скорость работы 2ого варианта')
print(getsizeof(a_frq))
print(end3 - start3, 'c - скорость работы 3ого варианта')
print(getsizeof(max_n2) + getsizeof(max_frq2))

# При n = 100000 и randint(0, 100000)
# 1ый вариант
# 0.02599620819091797 c - скорость работы 1ого варианта
# 2621564 б  (и всего 4724 б при randint(0, 100))
# 2ой вариант
# 107.67505073547363 c - скорость работы 2ого варианта
# 800984 б
# 3ий вариант
# 586.2917273044586 c - скорость работы 3ого варианта
# 56 б
# Выбор алгоритма зависит от входных данных. Например, если данных много (около 100000), и элементы массива имеют
# небольшой разброс (например храним возраст) и нам важна скорость, то стоит выбрать словарь (1й вариант). Если время не
# важно, но важно место, то выбираем 3ий вариант.
